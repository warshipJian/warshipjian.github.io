(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{364:function(e,r,t){"use strict";t.r(r);var o=t(26),n=Object(o.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[e._v("时光匆匆，转眼2020年也只剩下2个多月了，感慨之。")]),e._v(" "),t("p",[e._v("今天来介绍下docker中用到的一个核心技术Namespace，由于个人能力有限，不会深入到具体的细节。")]),e._v(" "),t("p",[e._v("私认为一个基础的docker需具备以下功能：")]),e._v(" "),t("p",[t("strong",[e._v("1.资源隔离")]),e._v("。即各个容器都是独立的，只能使用本容器的资源。比如每个容器只能看到自己的进程和文件，而看不到服务器上其他的进程和文件。每个容器的CPU和内存资源也是需要隔离的，不能出现某个容器把CPU占满，导致其他容器无法工作。")]),e._v(" "),t("p",[t("strong",[e._v("2.镜像功能")]),e._v("。一处构建，到处执行。用户在安装好docker后，直接拉取镜像即可运行使用。")]),e._v(" "),t("p",[e._v("为了实现这些，docker用到了"),t("code",[e._v("Namespace")]),e._v(","),t("code",[e._v("CGroups")]),e._v("和"),t("code",[e._v("UnionFS")]),e._v("。")]),e._v(" "),t("p",[t("code",[e._v("Namespace")]),e._v("：解决进程、网络、文件系统的资源隔离问题。")]),e._v(" "),t("p",[t("code",[e._v("CGroups")]),e._v("：解决内存、CPU等物理资源隔离问题。")]),e._v(" "),t("p",[t("code",[e._v("UnionFS")]),e._v("：解决镜像问题。")]),e._v(" "),t("p",[e._v("CGroups和UnionFS之前有简单介绍过，这次来看看Namespace。")]),e._v(" "),t("h3",{attrs:{id:"namespace简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#namespace简介"}},[e._v("#")]),e._v(" Namespace简介")]),e._v(" "),t("p",[e._v("Namespace 是Linux提供的一种内核级别隔离机制，目前提供的能力如下：")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("名称")]),e._v(" "),t("th",[e._v("宏")]),e._v(" "),t("th",[e._v("隔离资源")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("Cgroup")]),e._v(" "),t("td",[e._v("CLONE_NEWCGROUP")]),e._v(" "),t("td",[e._v("cgroup根目录")])]),e._v(" "),t("tr",[t("td",[e._v("Ipc")]),e._v(" "),t("td",[e._v("CLONE_NEWIPC")]),e._v(" "),t("td",[e._v("System V IPC(信号量、消息队列和共享内存)和POSIX message queues")])]),e._v(" "),t("tr",[t("td",[e._v("Network")]),e._v(" "),t("td",[e._v("CLONE_NEWNET")]),e._v(" "),t("td",[e._v("Network devices, stacks, ports, etc(网络设备、网络栈、端口等).")])]),e._v(" "),t("tr",[t("td",[e._v("Mount")]),e._v(" "),t("td",[e._v("CLONE_NEWNS")]),e._v(" "),t("td",[e._v("Mount points(文件系统挂载点)")])]),e._v(" "),t("tr",[t("td",[e._v("PID")]),e._v(" "),t("td",[e._v("CLONE_NEWPID")]),e._v(" "),t("td",[e._v("Process IDs(进程编号)")])]),e._v(" "),t("tr",[t("td",[e._v("User")]),e._v(" "),t("td",[e._v("CLONE_NEWUSER")]),e._v(" "),t("td",[e._v("User and group IDs(用户和用户组)")])]),e._v(" "),t("tr",[t("td",[e._v("UTS")]),e._v(" "),t("td",[e._v("CLONE_NEWUTS")]),e._v(" "),t("td",[e._v("Hostname and NIS domain name(主机名与NIS域名)")])])])]),e._v(" "),t("p",[e._v("以进程隔离为例，我们在启动docker时，会调用createSpec方法，创建docker的namespace。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('func (daemon *Daemon) createSpec(c *container.Container) (*specs.Spec, error) {\n\ts := oci.DefaultSpec()\n\n\t// ...\n\tif err := setNamespaces(daemon, &s, c); err != nil {\n\t\treturn nil, fmt.Errorf("linux spec namespaces: %v", err)\n\t}\n\n\treturn &s, nil\n}\n')])])]),t("p",[e._v("setNamespaces方法会设置容器的进程、用户、网络、IPC 以及 UTS 相关的命名空间：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('func setNamespaces(daemon *Daemon, s *specs.Spec, c *container.Container) error {\n\t// user\n\t// network\n\t// ipc\n\t// uts\n\n\t// pid\n\tif c.HostConfig.PidMode.IsContainer() {\n\t\tns := specs.LinuxNamespace{Type: "pid"}\n\t\tpc, err := daemon.getPidContainer(c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tns.Path = fmt.Sprintf("/proc/%d/ns/pid", pc.State.GetPID())\n\t\tsetNamespace(s, ns)\n\t} else if c.HostConfig.PidMode.IsHost() {\n\t\toci.RemoveNamespace(s, specs.LinuxNamespaceType("pid"))\n\t} else {\n\t\tns := specs.LinuxNamespace{Type: "pid"}\n\t\tsetNamespace(s, ns)\n\t}\n\n\treturn nil\n}\n')])])]),t("p",[e._v("通过docker exec 进入容器，你会发现所有pid是从1开始计数的,且看不到系统上其他的进程。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/ # ps aux\nPID   USER     TIME  COMMAND\n    1 root      0:00 npm\n   17 root      0:00 node /node_modules/.bin/egg-scripts start --title=egg-serv\n   28 root      0:13 node --require /node_modules/source-map-support/register.j\n   35 root      2:32 /usr/local/bin/node --require /node_modules/source-map-sup\n   46 root      2:21 /usr/local/bin/node --require /node_modules/source-map-sup\n   52 root      2:24 /usr/local/bin/node --require /node_modules/source-map-sup\n   75 root      0:00 sh\n   81 root      0:00 ps aux\n")])])]),t("p",[e._v("在系统上找一下这个docker进程：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[root@iZwz9eyfvpfa7klu4pa9odZ ~]# ps -ef | grep npm\nroot     1076972  431810  0 16:12 pts/0    00:00:00 grep --color=auto npm\nroot     2421826 2421807  0 9月18 ?       00:00:00 npm\n")])])]),t("p",[e._v("可以看到这个docker进程的pid是2421826，父进程是2421807。看下父进程2421807：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[root@iZwz9eyfvpfa7klu4pa9odZ ~]# ps -ef | grep 2421807\nroot     1030542 2421807  0 15:47 pts/0    00:00:00 sh\nroot     1088496  431810  0 16:18 pts/0    00:00:00 grep --color=auto 2421807\nroot     2421807    1731  0 9月18 ?       00:00:56 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/80e012862a8fe4b8cc636928f8b6022d7414ba176b752edadca426a1f34fe815 -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc -systemd-cgroup\nroot     2421826 2421807  0 9月18 ?       00:00:00 npm\n")])])]),t("p",[e._v("可以看到是containerd-shim，是docker的核心进程，它的父进程是1731。我们再找几个父进程是1731的其他containerd-shim进程，对比下他们的namespace：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[root@iZwz9eyfvpfa7klu4pa9odZ ~]# ps -ef | grep 1731\nroot        1731       1  0 9月14 ?       01:58:44 /usr/bin/containerd\nroot        2875    1731  0 9月14 ?       00:01:08 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/77c2595e8a78cd7f4c405b6ee445789414707e669ac050a655bc0baa90dc6ba0 -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc -systemd-cgroup\nroot        2887    1731  0 9月14 ?       00:01:04 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/1ae5ccfa0f656a3ce7ad1bf87e5d7c6302776676d76e0277463c9f43cf15e383 -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc -systemd-cgroup\nroot        2968    1731  0 9月14 ?       00:01:12 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/ebe45fdd5fcd8ab585954cc285ec8122f37107f05feb9447dadb6120365a1af9 -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc -systemd-cgroup\n")])])]),t("p",[e._v("以pid：2968为例，2968下有个/pause进程，pid是2988：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[root@iZwz9eyfvpfa7klu4pa9odZ ~]# ps -ef | grep 2968\nroot        2968    1731  0 9月14 ?       00:01:12 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/ebe45fdd5fcd8ab585954cc285ec8122f37107f05feb9447dadb6120365a1af9 -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc -systemd-cgroup\nroot        2988    2968  0 9月14 ?       00:00:00 /pause\n")])])]),t("p",[e._v("我们对比下2988和2421807的namespace：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[root@iZwz9eyfvpfa7klu4pa9odZ ~]# ll /proc/2988/ns\n总用量 0\nlrwxrwxrwx 1 root root 0 10月 10 16:29 cgroup -> cgroup:[4026531835]\nlrwxrwxrwx 1 root root 0 10月 10 16:29 ipc -> ipc:[4026532239]\nlrwxrwxrwx 1 root root 0 10月 10 16:29 mnt -> mnt:[4026532237]\nlrwxrwxrwx 1 root root 0 10月 10 16:29 net -> net:[4026531992]\nlrwxrwxrwx 1 root root 0 10月 10 16:29 pid -> pid:[4026532240]\nlrwxrwxrwx 1 root root 0 10月 10 16:29 pid_for_children -> pid:[4026532240]\nlrwxrwxrwx 1 root root 0 10月 10 16:29 user -> user:[4026531837]\nlrwxrwxrwx 1 root root 0 10月 10 16:29 uts -> uts:[4026532238]\n")])])]),t("p",[e._v("2421807如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[root@iZwz9eyfvpfa7klu4pa9odZ ~]# ll /proc/2421807/ns\n总用量 0\nlrwxrwxrwx 1 root root 0 10月 10 16:25 cgroup -> cgroup:[4026531835]\nlrwxrwxrwx 1 root root 0 10月 10 16:25 ipc -> ipc:[4026531839]\nlrwxrwxrwx 1 root root 0 10月 10 16:25 mnt -> mnt:[4026531840]\nlrwxrwxrwx 1 root root 0 10月 10 16:25 net -> net:[4026531992]\nlrwxrwxrwx 1 root root 0 10月 10 16:25 pid -> pid:[4026531836]\nlrwxrwxrwx 1 root root 0 10月 10 16:25 pid_for_children -> pid:[4026531836]\nlrwxrwxrwx 1 root root 0 10月 10 16:25 user -> user:[4026531837]\nlrwxrwxrwx 1 root root 0 10月 10 16:25 uts -> uts:[4026531838]\n")])])]),t("p",[e._v("可以发现他们的"),t("code",[e._v("ipc")]),e._v(","),t("code",[e._v("mnt")]),e._v(","),t("code",[e._v("pid")]),e._v(","),t("code",[e._v("pid_for_children")]),e._v("不同。")]),e._v(" "),t("h3",{attrs:{id:"docker网络互通"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker网络互通"}},[e._v("#")]),e._v(" docker网络互通")]),e._v(" "),t("p",[e._v("通过namespace把资源隔离后，网络也隔离了，此时需要解决容器间的网络互通问题。docker目前有"),t("code",[e._v("bridge")]),e._v("、"),t("code",[e._v("host")]),e._v("、"),t("code",[e._v("none")]),e._v("、"),t("code",[e._v("overlay")]),e._v("、"),t("code",[e._v("maclan")]),e._v(" 和 "),t("code",[e._v("Network plugins")]),e._v("等网络模式，在启动docker时通过"),t("code",[e._v("network")]),e._v("参数设置具体使用那一种模式。")]),e._v(" "),t("p",[e._v("以bridge模式为例，docker会给每个容器创建一对虚拟网卡，其中一个会加入到 docker0 网桥中，容器间的通信通过docker0来完成。容器和外部的通信使用NAT的方式，通过系统的iptables来实现。")]),e._v(" "),t("p",[e._v("值得一提的是，docker的这些功能都是通过"),t("code",[e._v("Libnetwork")]),e._v("来实现的。"),t("code",[e._v("Libnetwork")]),e._v("是从docker1.6开始，从docker项目中的网络部分抽离出来形成的容器网络模型，也被称为Container Network Model，简称"),t("code",[e._v("CNM")]),e._v("，由Sandbox, Endpoint, Network 三种组件组成。具体的细节可以查阅相关资料，这里就不多做介绍了。")]),e._v(" "),t("p",[e._v("值得二提的是，k8s用的是"),t("code",[e._v("CNI")]),e._v("模型，并非docker的CNM模型。在刚才的例子中，我们对比了两个容器的namespace，其中一个容器是"),t("code",[e._v("pause")]),e._v("，pause在k8s中提供了网络方面的功能，接管了pod里面其他容器的网络。在刚才的例子中也可以发现两者的net namespace是一致的。说到这里，索性就介绍下k8s下的docker网络通信吧：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.同一个pod里的容器通过localhost来通信。\n2.同一个node中pod间的容器通过docker0来通信。\n3.不同的node的pod间的容器通过Flannel、 Calico、 Romana、 Weave-net等网络插件来通信。\n")])])]),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://draveness.me/docker/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker 核心技术与实现原理"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.qikqiak.com/k8s-book/docs/7.Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker 的网络模式"),t("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=n.exports}}]);