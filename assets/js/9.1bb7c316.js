(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{359:function(t,a,r){"use strict";r.r(a);var s=r(26),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"关于并发-qps和tps"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#关于并发-qps和tps"}},[t._v("#")]),t._v(" 关于并发,QPS和TPS")]),t._v(" "),r("h3",{attrs:{id:"并发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并发"}},[t._v("#")]),t._v(" 并发")]),t._v(" "),r("p",[t._v("有时候我们醉心于业务逻辑的书写，可能忽视了并发，这里来唠叨一下，如果错了请指正。")]),t._v(" "),r("p",[t._v("在web开发中，并发指的是某个时间单位内对服务器产生的请求，一般指1秒内产生的请求。比如我们说1千并发就是指1秒内有1000请求发送到web服务器。并发数和会话数是不同的，并发是一定会对服务器产生压力的，而会话数可能只是‘挂’在服务器上，并没有查询数据库等操作。比如我们说秒杀场景并发高，是由于在那几秒内要完成下单，库存扣减等操作，这些操作会对服务器，数据库等产生巨大的压力。而要做一个大流量的静态页面则搞一台nginx服务器+CDN就足够了，因为这个场景很单纯，只是简单的页面输出，加上nginx这样优秀的开源软件和CDN后就变得很容易了。")]),t._v(" "),r("p",[t._v("笔者理解：在web开发中，大部分的企业基本都没有十万以上并发量，更多的是几百几千的并发。所以没必要去跟风高并发，有那个时间还不如多去看看操作系统，刷刷算法呢。")]),t._v(" "),r("h3",{attrs:{id:"压测"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#压测"}},[t._v("#")]),t._v(" 压测")]),t._v(" "),r("p",[t._v("说到并发，一般就会说压测。我们开发好了接口后，要对接口进行压测，目的不是为了写报告，而是为了对接口承受能力有一个大概的了解。如果要达到更大的并发，我们也能通过压测去找出瓶颈，做对应的优化。")]),t._v(" "),r("p",[t._v("压测工具有ab，jmeter，LoadRunner，以及云厂商的付费工具，比如阿里云的PTS性能测试。")]),t._v(" "),r("p",[t._v("一般的压测流程是先用jmeter压测，达到并发要求后可以再用云厂商的工具进行压测。")]),t._v(" "),r("h3",{attrs:{id:"qps"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#qps"}},[t._v("#")]),t._v(" QPS")]),t._v(" "),r("p",[t._v("说到压测，就会说QPS和TPS了。")]),t._v(" "),r("p",[t._v("QPS指的服务器每秒响应的请求数，比如服务器部署了接口A，这个接口每秒能对500个请求作出正常响应，压测更大的量就会抛出504等错误时，我们就称接口A的QPS是500。")]),t._v(" "),r("h3",{attrs:{id:"tps"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tps"}},[t._v("#")]),t._v(" TPS")]),t._v(" "),r("p",[t._v("TPS的概念则复杂些，不过也有简化版：TPS指每秒内完成的事务数。")]),t._v(" "),r("p",[t._v("这里的事务是指从请求服务器开始到服务器给出结果的过程。比如请求一个网页，从访问开始到页面输出结束，耗时1秒，则TPS是1。")]),t._v(" "),r("p",[t._v("事务要怎么产生呢，需要用户去请求，所以我们再引入用户的概念。1个用户1秒内完成1笔事务，此时TPS是1。如果有1000个用户同时请求且都正常呢？则TPS是1"),r("em",[t._v("1")]),t._v("1000 = 1000。在jmeter工具中配置的线程数就是这里的用户数。")]),t._v(" "),r("p",[t._v("那TPS和QPS的区别是什么？TPS是测试时我们自己去定义的，简单理解就是1个TPS包含1个或多个QPS。比如请求1个网页，网页在完成输出前会请求5个接口，则此时TPS是1，QPS是5。又比如我们把一次投票算做一个事务，这个投票包含获取投票数据和提交投票数据两个接口，则此时1TPS = 2QPS。再举个例子：把一次完整的游戏过程算做一个事物，这个过程需要登录，开始游戏，提交分数，抽奖，展示排行榜5个接口，则这里的1TPS = 5 QPS。")]),t._v(" "),r("h3",{attrs:{id:"rt"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rt"}},[t._v("#")]),t._v(" RT")]),t._v(" "),r("p",[t._v("RT是指接口的响应时间。")]),t._v(" "),r("h3",{attrs:{id:"rt-avg"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rt-avg"}},[t._v("#")]),t._v(" RT Avg")]),t._v(" "),r("p",[t._v("接口的平均响应时间。这个好比我们的人均收入，看看就好了。")]),t._v(" "),r("h3",{attrs:{id:"吞吐量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#吞吐量"}},[t._v("#")]),t._v(" 吞吐量")]),t._v(" "),r("p",[t._v("没有一个单独的吞吐量参数，评估吞吐量时可以通过QPS，TPS，RT来评估。在jemter的聚合报告中有个Throughput参数可以参考。")])])}),[],!1,null,null,null);a.default=v.exports}}]);