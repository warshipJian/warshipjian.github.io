(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{418:function(t,e,a){"use strict";a.r(e);var s=a(26),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"elk中logstash的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#elk中logstash的使用"}},[t._v("#")]),t._v(" ELK中logstash的使用")]),t._v(" "),a("h2",{attrs:{id:"logstash的处理过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#logstash的处理过程"}},[t._v("#")]),t._v(" logstash的处理过程")]),t._v(" "),a("p",[t._v("logstash在处理日志的整个过程是一个流的形式，按照 input -> filter-> output 这样的顺序进行。")]),t._v(" "),a("p",[t._v("(严格的说法是input -> decode -> filter -> encode -> output 这样的一个流，这里为了便于说明，简略下)")]),t._v(" "),a("p",[t._v("如图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://www.xiaoxiaoguo.cn/usr/uploads/2017/09/2669743690.png",alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("input")]),t._v("：负责日志的接收，服务端角色。比如收集各服务器的nginx日志，MySQL日志，系统日志，php慢日志等。")]),t._v(" "),a("p",[a("strong",[t._v("filter")]),t._v(": 对日志进行预处理等，后面会着重说下。")]),t._v(" "),a("p",[a("strong",[t._v("output")]),t._v(": 负责日志的输出，比如储存到哪个地方或者执行某些动作。")]),t._v(" "),a("h2",{attrs:{id:"input配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input配置"}},[t._v("#")]),t._v(" input配置")]),t._v(" "),a("p",[t._v("可以通过如下方式来接收日志：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("file：顾名思义，直接读文件\nstdin: 标准输入，调试配置的时候玩玩\nsyslog: syslog协议的日志格式，比如linux的rsyslog\ntcp/udp：使用tcp或udp传输过来的日志\n")])])]),a("p",[t._v("看一个file的配置")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('input {\n    file {\n        path => ["/var/log/*.log", "/var/log/message"]\n        type => "system"\n        start_position => "beginning"\n        codec => "json"\n    }\n}\n')])])]),a("p",[t._v("这些参数用途如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('path: 日志文件或目录的绝对路径，也可以是通配符的。\ntype: 类型，自定义\nstart_position: logstash 从什么位置开始读取文件数据，默认是结束位置，也就是说 logstash 进程会以类似 tail -F 的形式运行。如果你是要导入原有数据，把这个设定改成 "beginning"，logstash 进程就从头开始读取，类似 less +F 的形式运行。\ncodec: codec配置，通过它可以更好更方便的与其他有自定义数据格式的运维产品共存，比如 graphite、fluent、netflow、collectd，以及使用 msgpack、json、edn 等通用数据格式的其他产品等。\n')])])]),a("p",[t._v("再看一个tcp的配置")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('input {\n    tcp {\n        port => 8888\n        mode => "server"\n        ssl_enable => false\n    }\n\n\ttcp {\n        port => 9999\n        mode => "server"\n        ssl_enable => false\n    }\n}\n')])])]),a("p",[t._v("这里可以看到它支持ssl加密，传输更安全。")]),t._v(" "),a("p",[t._v("更多input的插件请参考: "),a("a",{attrs:{href:"https://www.elastic.co/guide/en/logstash/current/input-plugins.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Logstash Input"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"filter配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#filter配置"}},[t._v("#")]),t._v(" filter配置")]),t._v(" "),a("p",[t._v("这是今天的主菜：过滤器。")]),t._v(" "),a("p",[t._v("logstash收集到日志后，这些日志是原始的，但需求是多变的，比如日志中的有些内容要拆分成不同的字段，或者要把多种日志格式(比如有nginx日志，mysql慢日志等)统一成一种数据格式(比如json)等等，这些都通过filter来实现。")]),t._v(" "),a("p",[t._v("同input一样，filter也有各种各样的插件来处理日志，常见的有grok,ruby,kv,date等。这里主要介绍grok和ruby，详细参考"),a("a",{attrs:{href:"https://www.elastic.co/guide/en/logstash/current/input-plugins.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Logstash Filter Plugin"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("如果你的日志在生成阶段就已经处理好了，不需要额外的处理时，可以不用filter，logstash可这样配置：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('input {\n    file {\n        path => "/opt/logstash/log"\n        codec => "json"\n    }\n}\noutput{\n    stdout{\n        codec=>rubydebug\n    }\n}\n')])])]),a("h2",{attrs:{id:"grok"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#grok"}},[t._v("#")]),t._v(" grok")]),t._v(" "),a("p",[t._v("grok类似于grep命令，是一个正则表达式的插件，通过正则匹配出我们需要的内容。")]),t._v(" "),a("p",[t._v("比如nginx的日志如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('172.16.91.200 - - [19/Jan/2017:17:20:17 +0800] "GET /favicon.ico HTTP/1.1" 200 0 "http://172.16.93.237:9881/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36"\n')])])]),a("p",[t._v("我想把里面的ip 172.16.91.200存储到clientip中，之后我在kibana中查看时，通过clientip就能查到ip了。")]),t._v(" "),a("p",[t._v("看一下grok是怎么匹配的")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('%{IPORHOST:clientip} - - \\[%{HTTPDATE:request_time}\\] \\"(?:%{WORD:method} %{URIPATH:url}(?:%{URIPARAM:params})?(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\\" %{NUMBER:status} (?:%{NUMBER:bytes:int}|-) \\"%{DATA:referrer}\\" \\"%{DATA:agent}\\"\n')])])]),a("p",[t._v("可以发现，它的形式并不像我们平常写的正则表达式。")]),t._v(" "),a("p",[t._v("看下grok语法：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("%{PATTERN_NAME:capture_name:data_type}\n")])])]),a("p",[t._v("这里有三部分PATTERN_NAME，capture_name，data_type。")]),t._v(" "),a("p",[a("strong",[t._v("1. PATTERN_NAM")])]),t._v(" "),a("p",[t._v("正则变量，指向一个正则表达式，可以自定义，如")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("USERNAME [a-zA-Z0-9._-]+  #定义个正则表达式的变量\nUSER %{USERNAME} #使用这个正则表达式\n")])])]),a("p",[t._v("logstash默认提供了很多的正则表达式，具体可参考："),a("a",{attrs:{href:"https://github.com/elastic/logstash/blob/v1.4.2/patterns/grok-patterns",target:"_blank",rel:"noopener noreferrer"}},[t._v("Logstash Grok Patterns"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("在调试grok时，可以借助下**"),a("a",{attrs:{href:"http://grokdebug.herokuapp.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Grok Debugger"),a("OutboundLink")],1),t._v("**。")]),t._v(" "),a("p",[t._v("回到刚才的grok，匹配客户端ip的部分是:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("%{IPORHOST:clientip}\n")])])]),a("p",[t._v("这里的正则用了IPORHOST，它实际内容如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("IPORHOST (?:%{HOSTNAME}|%{IP})\n")])])]),a("p",[t._v("可以看到它引用了两个正则变量HOSTNAME和IP，这两个的实际内容如下:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("HOSTNAME \\b(?:[0-9A-Za-z][0-9A-Za-z-]{0,62})(?:\\.(?:[0-9A-Za-z][0-9A-Za-z-]{0,62}))*(\\.?|\\b)\nIP (?:%{IPV6}|%{IPV4})\n")])])]),a("p",[t._v("IP又引用了两个正则变量IPV4和IPV6。")]),t._v(" "),a("p",[a("strong",[t._v("2. capture_name")])]),t._v(" "),a("p",[t._v("可以理解为把匹配的值存储到哪个field中。比如这里的ip匹配，存储为clientip。")]),t._v(" "),a("p",[a("strong",[t._v("3. data_type")])]),t._v(" "),a("p",[t._v("数据类型，不是必填项。默认是字符串，其他类型还有float，int等。")]),t._v(" "),a("p",[t._v("了解了这三部分内容后，再看grok的配置就明了了。")]),t._v(" "),a("p",[t._v("看一个完整的配置：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('input {\n    file {\n        path => "/opt/logstash/log"\n    }\n}\n\nfilter {\n    grok {\n        match => {\n\t    "message" => "%{IPORHOST:clientip} - - \\[%{HTTPDATE:request_time}\\] \\"(?:%{WORD:method} %{URIPATH:url}(?:%{URIPARAM:params})?(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\\" %{NUMBER:status} (?:%{NUMBER:bytes:int}|-) \\"%{DATA:referrer}\\" \\"%{DATA:agent}\\""\n        }\n    }\n}\n\noutput{\n    stdout{\n        codec=>rubydebug\n    }\n}\n')])])]),a("h2",{attrs:{id:"ruby"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ruby"}},[t._v("#")]),t._v(" ruby")]),t._v(" "),a("p",[t._v("通过filters/ruby插件，可以在filter中使用ruby，极大地方便了日志处理。")]),t._v(" "),a("p",[t._v("看一个官方的示例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("filter {\n    ruby {\n        init => \"@kname = ['client','servername','url','status','time','size','upstream','upstreamstatus','upstreamtime','referer','xff','useragent']\"\n        code => \"\n            new_event = LogStash::Event.new(Hash[@kname.zip(event.get('message').split('|'))])\n            new_event.remove('@timestamp')\n\t        event.append(new_event)\"\n    }\n}\n")])])]),a("p",[t._v("参数如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("init:用来预定义参数。\ncode:要运行的ruby语句。\n")])])]),a("p",[t._v("比如我想对nginx日志进行一个简单的归类，区分下动态和静态资源。把css，图片，字体归为静态资源，其他的划为动态。配置示例如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("input {\n    file {\n        path => \"/opt/logstash/log\"\n        codec => \"json\"\n    }\n}\n\nfilter {\n    if [url] {\n\t\truby {\n\t        code => \"\n\t            url_match = /(.*).(css|js|png|html|gif|png|woff)$/.match(event.get('url'))\n\t            if ( url_match )\n\t                url_type = 'static'\n\t            else\n\t                url_type = 'dynamic'\n\t            end\n\t\t\t    event.set('url_type',url_type)\n\t\t\"\n\t\t}\n\t}\n}\n\noutput{\n    stdout{\n        codec=>rubydebug\n    }\n}\n")])])]),a("p",[t._v("用logstash运行测试下，可以看到多了个值url_type")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/opt/logstash/bin/logstash -f /etc/logstash/conf.d/test.conf\n")])])]),a("h2",{attrs:{id:"output配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output配置"}},[t._v("#")]),t._v(" output配置")]),t._v(" "),a("p",[t._v("output负责把处理好日志输出到指定的地方，和input一样，output也有丰富的插件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("elasticsearch：可以通过http等方式存入elasticsearch 中\nemail：通过邮件发送出去\nfile: 存到文件中\nnagios：发送到nagios中\nexce: 执行某个程序或命令\nstatsd:输出到statsd中 \nstdout:有标准输入，那就有标准输出\ntcp/udp:通过tcp/udp输出\nHDFS:输出到hadoop中，搞大数据:)\n")])])]),a("p",[t._v("这里主要看下输出到elasticsearch的配置。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('output {\n    elasticsearch {\n        hosts => ["192.168.0.2:9200"]\n        index => "logstash-%{type}-%{+YYYY.MM.dd}"\n        document_type => "%{type}"\n        flush_size => 20000\n        idle_flush_time => 10\n        sniffing => true\n        template_overwrite => true\n    }\n}\n')])])]),a("p",[t._v("主要参数如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("host: es的主机和端口\nindex:写入es的索引名称\ndocument_type：es的document_type\nflush_size:指定数据达到多少条时再发送\nidle_flush_time：结合flush_size使用，指在这个时间内即使没攒够flush_size数，也发送。比如flush_size设置1000条，idle_flush_time设置为5秒，则在这5秒中，即使数目没达到1000条也会发送。而如果到3秒时就有1000条了，则会立即发送。\n")])])]),a("h2",{attrs:{id:"结语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[t._v("#")]),t._v(" 结语")]),t._v(" "),a("p",[t._v("logstash的input，filter，output三个阶段都有很丰富的插件，可根据自己的需求来搭配使用。")]),t._v(" "),a("p",[t._v("每部分可配置多个不同的内容，比如input可以同时配置file和tcp，并且配置多个tcp。")]),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("p",[a("a",{attrs:{href:"http://tonghs.com/2017/04/08/Logstash-%E5%88%B0%E5%BA%95%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Logstash 到底该怎么用"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://kibana.logstash.es/content/logstash/",target:"_blank",rel:"noopener noreferrer"}},[t._v("logstash使用指南"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);