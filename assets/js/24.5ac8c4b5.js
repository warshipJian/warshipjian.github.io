(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{372:function(t,n,s){"use strict";s.r(n);var a=s(26),o=Object(a.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"守护进程-04-nohup"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#守护进程-04-nohup"}},[t._v("#")]),t._v(" 守护进程-04-nohup")]),t._v(" "),s("p",[t._v("我们要结束一个进程时可以通过kill命令来实现，kill的过程简单来说是这样：")]),t._v(" "),s("ol",[s("li",[t._v("使用kill将信号发送到进程的task_struct中，task_struct的特定的成员变量里记下这个信号")]),t._v(" "),s("li",[t._v("下一次CPU调度到这个进程的时，内核会先执行"),s("code",[t._v("do\\_signal")]),t._v("，处理信号")])]),t._v(" "),s("p",[t._v("使用"),s("code",[t._v("kill -l")]),t._v(" 命令可以查看kill能发送的信号")]),t._v(" "),s("h3",{attrs:{id:"nohup"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nohup"}},[t._v("#")]),t._v(" nohup")]),t._v(" "),s("p",[t._v("除了利用工具（tmux，screen等），daemon自守护，systemed系统外，我们还可以用nohup来实现进程守护的需求。\n使用方式很简单：在要执行的命令前加个nohup即可，如果要后台执行则在末尾加个&。\n回到之前的例子：")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello %d \\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fflush")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("stdout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("我们通过nohup来把它运行起来：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("root@lan-dev-215:~/test# nohup a.out\nnohup: ignoring input and appending output to 'nohup.out'\n")])])]),s("p",[t._v("可以看到有句提示： "),s("code",[t._v("ignoring input and appending output to 'nohup.out")]),t._v("，忽略输入，输出到nohup.out文件。\n此时关掉该终端会发现a.out还是在运行。\nnohup命令这么简单易用，是怎么实现的呢？\n看看nohup.c的源码 https://gist.github.com/kohsuke/0eeb9bb43ca8d62643dd\n关键是这两行：")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("signal")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SIGHUP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" SIG_IGN"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("execvp")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("cmd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" cmd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("通过signal (SIGHUP, SIG_IGN)，把SIGHUP信号忽略，kill 1对它是无效；然后通过execvp (*cmd, cmd) 切换程序背景，nohup把自己变成了a.out，从而实现了我们的守护需求。\n来试验下。\n先通过nohup 跑起来，然后kill -1一下试试，发现还在运行")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("root@lan-dev-215:~/test# nohup ./a.out \nnohup: ignoring input and appending output to 'nohup.out'\n^C\nroot@lan-dev-215:~/test# nohup ./a.out &\n[1] 27668\nroot@lan-dev-215:~/test# nohup: ignoring input and appending output to 'nohup.out'\n\nroot@lan-dev-215:~/test# kill -1 27668\nroot@lan-dev-215:~/test# ps aux | grep a.out\nroot     27668  0.0  0.0   4508   712 pts/1    S    18:21   0:00 ./a.out\nroot     27674  0.0  0.0  14428  1040 pts/1    S+   18:21   0:00 grep --color=auto a.out\n")])])]),s("p",[s("code",[t._v("IGNORED")]),t._v("位被置为1了")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("root@lan-dev-215:~/test# ps -C a.out s\n  UID   PID          PENDING          BLOCKED          IGNORED           CAUGHT STAT TTY        TIME COMMAND\n    0 27668 0000000000000000 0000000000000000 0000000000000001 0000000000000000 S    pts/1      0:00 ./a.out\n")])])]),s("p",[t._v("标准输入0被定向到了"),s("code",[t._v("/dev/null")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("root@lan-dev-215:~/test# lsof -p 27668\nCOMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME\na.out   27668 root  cwd    DIR    8,1     4096 2752642 /root/test\na.out   27668 root  rtd    DIR    8,1     4096       2 /\na.out   27668 root  txt    REG    8,1     8696 2753343 /root/test/a.out\na.out   27668 root  mem    REG    8,1  2030544 5767667 /lib/x86_64-linux-gnu/libc-2.27.so\na.out   27668 root  mem    REG    8,1   170960 5767639 /lib/x86_64-linux-gnu/ld-2.27.so\na.out   27668 root    0w   CHR    1,3      0t0       6 /dev/null\na.out   27668 root    1w   REG    8,1     3328 2753344 /root/test/nohup.out\na.out   27668 root    2w   REG    8,1     3328 2753344 /root/test/nohup.out\n")])])]),s("p",[t._v("感兴趣的话可以去对比下不加"),s("code",[t._v("nohup")]),t._v("时这些的区别。")])])}),[],!1,null,null,null);n.default=o.exports}}]);